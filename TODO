This is a random list of things that either would be good to do, or would be
good to consider doing. Some of these are mutually-incompatible (or at least,
mutually-undesirable).

Some of these may also be impossible! :)


0. Figure out how to make the implicit decorations for inline operators faster

Supposedly escape analysis can optimize away the objects created by the
implicit decorator pattern but I have yet to see evidence of this when dealing
with AnyVal types like Int. I don't know how to make this faster, but it is the
#1 problem with this library (and Numeric in general).


1. Implement a c.a.m.NumericRange class in terms of c.a.m.Numeric

Paul Phillips has encouraged me to do this. I managed to create something that
worked but wasn't performing as well as the direct integer ranges. The problem
seemed to be the difference between the way foo(Int => Unit) and foo[T](T =>
Unit) are treated. 


2. Add BigInt, BigDecimal support

These probably won't be super fast, but it would be nice to support them.


3. Try creating some kind of complex type

This could be something like case class Complex(real:Double, imag:Double)
or maybe even something crazier like Complex[T:Numeric](real:T, imag:T)


4. Create implicit conversions using toNumeric[T]

This would allow someone to say 3.toNumeric[T] rather than having to get a
reference to the Numeric instance and say n.fromInt(3).


5. Specialize Ordering

This is probably too big for this project, but it would be great if Ordering
were specialized so that Numeric could extend it without taking a huge speed
hit on things like Numeric.lt().


6. Rationalize working with two different numeric types

Currently if you have "def complicated[T:Numeric, U:Numeric](t:T, u:U)" you
will have to do manual conversions to one of those types without being sure
that you aren't losing precision. I'm not sure there's a way to get around
this, but it might be nice to have a way to compare two Numeric objects in
terms of which one should "win" in terms of precision. That way you could at
least say something like "if (n1.morePreciseThan(n2)) ... else ..."

I'm not sure how often this would be used, but I could imagine it being nice.


7. Worry about Hotspot de-inlining in Main.scala

I tried to save some code by using inheritence, but it's possible that this is
making certain tests run slower (as I found out while writing the IncrementInt*
family of tests). It would be great to try to make sure that this isn't a
problem.


8. Test on more hardware/JVM configurations


9. Port tests to one of the newer performance testing frameworks


10. Write more tests
