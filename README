This is a package I've built to show some basic improvements in speed we can
get with a better Numeric trait. It features specialization among other
improvements and it can be used productively right now. 

Soon I hope to release this as an independent jar that people can plug in to
do fast generic math, and eventually I hope to get code like this integrated
into the core Scala library.

=== BENCHMARKS ===

You can run the performance tests with "sbt run".

The output shows the speed (in ms) of a direct implementation (without
generics), the new implementation (com.azavea.math.Numeric) and the old
implementation (the built-in scala.math.Numeric).

  n:d is how new compares to direct
  o:d is how old compares to direct
  o:n is how old compares to new

It also creates a benchmark.html file which colors the output.

=== RESULTS ===

There are some interesting results:

1. scala.math.Numeric performs terribly on integral types but does a bit better
on fractional ones.

2. com.azavea.math.Numeric mostly performs as well as direct except when
using infix operators*. The current Numeric is clearly inappropriate for any
application where performance is important.

3. The asterisk (*) in the previous item has to do with Quicksort. Basically,
scala.util.Sorting uses Ordering[A] which is not specialized and which
implements all its own (non-specialized) comparison operators in terms of
compare().

This ends up being really slow, so my Numeric trait doesn't extend it, but
instead provides a getOrdering() method (which builds a separate Ordering
instance wrapping the Numeric instance). As a result, it doesn't perform any
better than scala.math.Numeric on this test (and in fact does a bit worse).

I don't know how reasonable it is to specialize Ordering but huge performance
gains seem possible.

4. scala.util.Sorting.quickSort lacks a direct Long implementation, so using it
with Longs is ~5x slower than Int, Float or Double.

5. It seems like scala.util.Sorting could use some love. My naive direct
implementation of merge sort seems to beat Sorting.quickSort for long
(obviously), float and double. That said, I haven't looked at it closely and
tuning sort algorithms is tricky.

=== DIFFERENCES ===

While very similar to scala.math.Numeric, com.azavea.math.Numeric has
some differences. The most significant ones are:

1. It does not inherit from the Ordering type class, but rather directly
implements the comparison methods. I will try to do some cleanup on this and
make it more compatible with Ordering, but it was important to me that the
comparison methods are also specialized.  

2. It does not implement Integral/Fractional. I think that leaving
division/modulo off of Numeric is a mistake, and don't think that forcing users
to use Integral/Fractional is a good idea. Given that Scala uses the same
symbol (/) to mean both "integer division" and "true division" it seems clear
that Numeric can too. 

3. It's in a different package.

4. In addition to the "normal" math operators like +, -, etc, it implements
versions with a ~ suffix, e.g. +~, -~, *~, etc. Unlike the "normal" ones these
allow you to mix number literals and generic types freely. For instance:

  def foo[T:Numeric](a:T) = (a *~ 2) +~ 3

Unfortunately you do have to use parenthesis because these operators lack the
normal precedence rules.
 